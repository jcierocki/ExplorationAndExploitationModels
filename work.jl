#### workfile

using Plots

#### Mutual learning

include("march_mutual_learning.jl")

const N_ITER = 100
const N_AGENTS = 50
const N_STATES = 30

my_env = MarchMutualLearning.InitialEnvironment(N_STATES, N_AGENTS)


####

plt = plot()

for p₂ in [0.1, 0.5, 0.9]
    plot!(plt, 0.1:0.1:0.9, map(p₁->MarchMutualLearning.simulate(my_env, N_ITER, p₁, p₂)[2], 0.1:0.1:0.9), label = p₂)
end

plt

####

plt = plot()

low_value_fractions = [ (9 - 10 * x) / 8 for x in 0.2:0.1:0.8 ]
p₁_series = [ vcat(fill(0.1, frac), fill(0.9, N_AGENTS - frac)) for frac in Int64.(round.(N_AGENTS .* low_value_fractions)) ]

plot!(plt, 0.2:0.1:0.8, map(p₁->MarchMutualLearning.simulate(my_env, N_ITER, p₁, 0.5)[2], 0.2:0.1:0.8), label = "homo")
plot!(plt, 0.2:0.1:0.8, map(p₁->MarchMutualLearning.simulate(my_env, N_ITER, p₁, 0.5)[2], p₁_series), label = "hetero")

plt

####

plt = plot()

test3_range = 0:0.1:1.0
p₁_series = [ vcat(fill(0.1, frac), fill(0.9, N_AGENTS - frac)) for frac in Int64.(N_AGENTS .* test3_range) ]

code_res = Vector{Float64}()
agents_res = Vector{Float64}()
better_agents_res = Vector{Float64}()
worse_agents_res = Vector{Float64}()

for p₁ in p₁_series
    res = MarchMutualLearning.simulate(my_env, N_ITER, p₁, 0.5)
    push!(code_res, res[1])
    push!(agents_res, res[2])
    push!(better_agents_res, res[3])
    push!(worse_agents_res, res[4])
end

plot!(plt, test3_range, code_res, label = "code")
plot!(plt, test3_range, agents_res, label = "agent overall")
plot!(plt, test3_range, better_agents_res, label = "better agents")
plot!(plt, test3_range, worse_agents_res, label = "worse agents")

plt

#### Competition

include("march_competition.jl")

my_range = 0:0.05:2
plot(my_range, MarchCompetition.calc_mean_curve(100, my_range))
plot!(my_range, MarchCompetition.calc_mean_curve(10, my_range))
plot!(my_range, MarchCompetition.calc_mean_curve(2, my_range))
