using Statistics, Random

init_reality(m) = rand((-1,1), m)

function init_tacit(m, q)
    x = falses(m)
    x[1:Int(q*m)] .= true
    shuffle!(x)
end

init_code(m) = fill(0, m)

function init_beliefs(m, n)
    k = isqrt(n)
    @assert k*k == n
    [rand((-1, 0, 1), m) for i in 1:k, j in 1:k]
end

function update_beliefs!(b, c, p1)
    for v in b
        for i in eachindex(v)
            if c[i] != 0 && c[i] != v[i]
                if rand() < p1
                    v[i] = c[i]
                end
            end
        end
    end
end

fitness(x, r) = sum(x[i] == r[i] for i in eachindex(x))

function learn_socially!(b, r, p3, p4)
    rows, cols = size(b)
    for a in shuffle(CartesianIndices(b))
        x, y = Tuple(a)
        Δ = shuffle([(1,1), (1,-1), (-1,1), (-1,-1)])
        neis_loc = [b[mod1(x+dx, rows), mod1(y+dy, cols)] for (dx, dy) in Δ]
        best_loc = neis_loc[argmax(fitness.(neis_loc, Ref(r)))]
        if fitness(best_loc, r) >= fitness(b[a], r)
            for i in eachindex(b[a])
                if best_loc[i] != 0 && rand() < p3
                    b[a][i] = best_loc[i]
                end
            end
        else
            newinds = CartesianIndex{2}[]
            while length(newinds) < 4
                x = rand(CartesianIndices(b))
                x == a || x in newinds || push!(newinds, x)
            end
            neis_dist = getindex.(Ref(b), newinds)
            best_dist = neis_dist[argmax(fitness.(neis_dist, Ref(r)))]
            if fitness(best_dist, r) >= fitness(b[a], r)
                for i in eachindex(b[a])
                    if best_dist[i] != 0 && rand() < p4
                        b[a][i] = best_dist[i]
                    end
                end
            end
        end
    end
end

function update_code!(b, c, r, p2, t)
    fit_c = fitness(c, r)
    b_good = filter(v -> fitness(v, r) > fit_c, b)
    for i in eachindex(c)
        t[i] && continue
        n₁ = count(==(1), getindex.(b_good, i))
        n₀ = count(==(0), getindex.(b_good, i))
        n₋₁ = count(==(-1), getindex.(b_good, i))
        if n₁ > n₋₁
            if c[i] != 1
                if rand() < p2
                    c[i] = 1
                end
            end
        end
        if n₁ < n₋₁
            if c[i] != -1
                if rand() < p2
                    c[i] = -1
                end
            end
        end
        if n₁ == n₋₁
            if c[i] != 0
                if rand() < p2
                    c[i] = 0
                end
            end
        end
    end
end

function runsim(m, n, p1, p2, p3, p4, q, τ, T)
    r = init_reality(m)
    c = init_code(m)
    b = init_beliefs(m, n)
    t = init_tacit(m, q)
    f = Float64[]
    for i in 1:T
        learn_socially!(b, r, p3, p4)
        if i % τ == 0
            update_code!(b, c, r, p2, t)
            update_beliefs!(b, c, p1)
        end
        push!(f, fitness(c, r) / m)
    end
    f
end

M = 150
N = 100
p1 = 0.5
p2 = 0.5
p3 = 0.5
p4 = 0.5
q = 0.5
τ = 1
T = 70
res = runsim(M, N, p1, p2, p3, p4, q, τ, T)
