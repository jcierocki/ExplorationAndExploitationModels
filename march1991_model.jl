using Statistics, Plots

init_reality(m) =rand((-1,1), m)
init_code(m) = fill(0, m)
init_beliefs(m, n) = [rand((-1, 0, 1), m) for i in 1:n]

function update_beliefs!(b, c, p1)
    canchange = false
    for v in b
        for i in eachindex(v)
            if c[i] != 0 && c[i] != v[i]
                canchange = true
                if rand() < p1
                    v[i] = c[i]
                end
            end
        end
    end
    canchange
end

fitness(x, r) = sum(x[i] == r[i] for i in eachindex(x))

function update_code!(b, c, r, p2)
    canchange = false
    fit_c = fitness(c, r)
    b_good = filter(v -> fitness(v, r) > fit_c, b)
    for i in eachindex(c)
        n₁ = count(==(1), getindex.(b_good, i))
        n₀ = count(==(0), getindex.(b_good, i))
        n₋₁ = count(==(-1), getindex.(b_good, i))
        if n₁ > n₋₁
            if c[i] != 1
                canchange = true
                if rand() < 1 - (1-p2)^(n₁-n₋₁)
                    c[i] = 1
                end
            end
        end
        if n₁ < n₋₁
            if c[i] != -1
                canchange = true
                if rand() < 1 - (1-p2)^(n₋₁-n₁)
                    c[i] = -1
                end
            end
        end
    end
    return canchange
end

function runsim(m, n, p1, p2)
    r = init_reality(m)
    c = init_code(m)
    b = init_beliefs(m, n)
    c1, c2 = true, true
    while c1 || c2
        c1 = update_beliefs!(b, c, p1)
        c2 = update_code!(b, c, r, p2)
    end
    fitness(c, r) / m
end

const M = 30
const N = 50

p1 = 0.1:0.1:0.9
p2 = [0.1 0.5 0.9]
res = mean(runsim.(M, N, p1, p2) for i in 1:100)
plot(p1, res, label = p2)
# legend(string.(vec(p2)))
