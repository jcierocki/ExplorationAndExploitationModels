#### march model I

mutable struct StatesVec{T<:Signed}
    states::Vector{T}
end

mutable struct InitialEnvironment{T}
    agents::Vector{StatesVec{T}}
    reality::StatesVec{T}
end

function StatesVec(len::Integer, vals::NTuple{N,T} = (Int8(-1), Int8(0), Int8(1)))::StatesVec{T} where {N,T}
    StatesVec(rand(vals, len))
end

function InitialEnvironment(m::T, n::T) where T<:Integer ## do dodania generyczność
    InitialEnvironment(
        [StatesVec(m) for i in 1:n],
        StatesVec(m, (Int8(-1), Int8(1)))
    )
end

function learn!(learner::StatesVec{T}, teacher::StatesVec{T}, p₁::Real) where T
    idx = (teacher.states .!= T(0)) .& (rand(length(teacher.states)) .<= p₁)
    view(learner.states, idx)[:] .= view(teacher.states, idx)
    # view(learner.states, idx)[:] .= teacher.states[idx]
end

function measure_compatibility(entity1::StatesVec{T}, entity2::StatesVec{T})::Integer where T
    sum(entity1.states .== entity2.states)
end

function count_views(dim::Integer, agents::AbstractVector{StatesVec{T}}, vals::NTuple{N,T} = (Int8(-1), Int8(0), Int8(1)))::Vector{Integer} where {N,T}
    map(v->count(a->a.states[dim]==v, agents), collect(vals))
end

function find_majority_view(counted_views::Vector{Integer}, vals::NTuple{N,T} = (Int8(-1), Int8(0), Int8(1))) where {N,T}
    vals[argmax(counted_views)]
end

function calc_change_probability(dim::Integer, counted_views::Vector{Integer}, majority_view::T, org_code::StatesVec{T}, p₂::Real, vals::NTuple{N,T} = (Int8(-1), Int8(0), Int8(1)))::Real  where {N,T}
    if majority_view == org_code.states[dim]
        return 0
    end

    idx = org_code.states[dim] .== collect(vals)
    1 - (1 - p₂)^(sum(counted_views[.!idx]) - sum(counted_views[idx]))
end

function adjust!(org_code::StatesVec{T}, reality::StatesVec{T}, agents::AbstractVector{StatesVec{T}}, p₂::Real) where T
    code_comp = measure_compatibility(org_code, reality)
    better_comp_agents = view(agents, map(a->measure_compatibility(a, reality), agents) .> code_comp)

    for i in eachindex(org_code.states)
        counted_views = count_views(i, agents)
        majority_view = find_majority_view(counted_views)
        prob = calc_change_probability(i, counted_views, majority_view, org_code, p₂)

        if rand() <  prob
           org_code.states[i] = majority_view
        end
    end
end

function update_mean(m::T, new_val::T, n::Integer) where T<:Real
    (m * n + new_val) / (n + 1)
end

function simulate(env::InitialEnvironment{T}, rep::V, p₁::U, p₂::U, p₃::U = U(0), p₄::U = U(0), eq_precision::V = 4) where {T, U<:Real, V<:Integer}
    simulate(env, rep, fill(p₁, length(env.agents)), p₂, p₃, p₄, eq_precision)
end

function simulate(env::InitialEnvironment{T}, rep::V, p₁::Vector{U}, p₂::U, p₃::U = U(0), p₄::U = U(0), eq_precision::V = 4) where {T, U<:Real, V<:Integer}
    # println("START")
    m, n = length(env.reality.states), length(env.agents)
    code_comp_mean, agents_comp_mean = 0.0, 0.0

    for i in 1:rep
        org_code = StatesVec(fill(T(0), m))
        agents = deepcopy(env.agents)
        reality = deepcopy(env.reality)
        agents_comp = Vector{Real}()

        j = 1
        while j <= 3 || (agents_comp[j-1] != agents_comp[j-2] || agents_comp[j-1] != agents_comp[j-3])
            # println("period", j)
            # println((measure_compatibility(org_code, reality)/m, sum(a->measure_compatibility(a, reality)/m, agents)/n))
            if p₄ > 0
                idx = rand(n) .< p₄
                view(reality.states, idx)[:] *= T(-1)
            end

            push!(agents_comp, round(sum(a->measure_compatibility(a, reality)/m, agents)/n, digits = eq_precision))
            for k in eachindex(agents)
                if rand() < p₃
                    agents[k] = StatesVec(m)
                end

                learn!(agents[k], org_code, p₁[k])
            end
            adjust!(org_code, reality, agents, p₂)
            j += 1
        end

        code_comp_mean = update_mean(code_comp_mean, measure_compatibility(org_code, reality)/m, i - 1)
        agents_comp_mean = update_mean(agents_comp_mean, sum(a->measure_compatibility(a, reality)/m, agents)/n, i - 1)
    end

    code_comp_mean, agents_comp_mean
end
